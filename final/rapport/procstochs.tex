\subsection{Introduction}
  La programmation stochastique cherche à étudier la progression au cours du
  temps de processus aléatoires.
  %todo blabla?

\subsection{Théorie des files d'attente}
  Une file d'attente est un système ayant une entrée par laquelle arrivent des
  tâches, ou client, qui attendent leur tour avant d'être traitée une pour en
  sortir.

  Elles sont utilisées pour l'étude de beaucoup de systèmes: attentes de
  clients à des guichets, trafic routier, traitement des tâches par un
  serveur, etc.

  \paragraph{}
  Les files sont étudiées en fonction de la loi qui gère l'entrée, la loi qui
  gère la sortie et le nombre de ``serveurs'' qui traitent les clients.

  La loi de Little est cependant un résultat général:
    \[N = \lambda T_s\]
  où $N$ est le nombre moyen de clients dans le système, $\lambda$ la fréquence
  moyenne d'entrée et $T_s$ le temps moyen passé dans le système.

  \subsubsection{Cas M/M/1}
    On considère une file d'attente où la loi d'entrée suit une loi de Poisson
    de paramètre $\lambda$ ($\lambda$ est dont le nombre moyen d'arrivées par
    unité de temps) et que le temps de service suit une loi exponentielle de
    paramètre $\mu$ ($\frac 1 \mu$ est donc le temps moyen de traitement, sans
    compter l'attente dans la file).

    On dit que ce genre de file d'attente est de type $M/M/1$ selon les
    notations de Kendall.

    Dans ce cas, le nombre moyen d'arrivées pendant le temps de service, appelé
    trafic offert, est $\rho = \frac \lambda \mu$. Le système converge alors si
    et seulement si $\rho < 1$.
    
    \paragraph{}
    La file peut être représentée comme une chaîne de Markov où chaque état $i$
    représente la probabilité qu'il y ait $i$ voitures dans le système (voir
    figure~\ref{fig:markov1}).

    \begin{figure}[h]
      \centering
      \begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2cm,semithick]
        \tikzstyle{every state}=[fill=white,draw=black,text=black,minimum size=1.1cm]

        \node[state] (A) {0};
        \node[state] (B) [right of=A] {$1$};
        \node[state] (C) [right of=B] {$2$};
        \node[state] (D) [right of=C] {$3$};
        \node[minimum size=1cm] (E) [right of=D] {$\cdots$};

        \path (A) edge [bend left] node {$\lambda$} (B);
        \path (B) edge [bend left] node {$\mu$} (A);
        \path (B) edge [bend left] node {$\lambda$} (C);
        \path (C) edge [bend left] node {$\mu$} (B);
        \path (C) edge [bend left] node {$\lambda$} (D);
        \path (D) edge [bend left] node {$\mu$} (C);
        \path (D) edge [bend left] node {$\lambda$} (E);
        \path (E) edge [bend left] node {$\mu$} (D);
      \end{tikzpicture}
      \caption{Représentation d'une file M/M/1 comme une chaine de Markov
        \cite{procstochs_cc}}
      \label{fig:markov1}
    \end{figure}

    Ces états sont liés en régime permanent par les équations:
      \[
        \left\{\begin{aligned}
          \lambda p_0 & = \mu p_1 \\
          \lambda p_1 & = \mu p_2 \\
          & \cdots \\
          \lambda p_n & = \mu p_{n+1} \\
          & \cdots 
        \end{aligned}\right.
      \]
    et
      \[
        \sum_{i=0}^{+\infty} p_n = 1
      \]

    D'où $p_n = \left(\frac \lambda \mu\right)^n p_0 =
     \left(\frac \lambda \mu\right)^n \left(1-\frac \lambda \mu\right) =
     \rho^n (1-\rho)$ (d'où la condition $\rho < 1$).

   Le nombre moyen de clients dans le système est donc:
     \[ N = \sum_{i=0}^n np_n = \frac \rho {1-\rho} \]

   D'après la loi de Little, le temps moyen passé dans le système est donc:
     \[
       T_s = \frac 1 \lambda \frac \rho {1-\rho}
           = \rho \frac \lambda {\mu-\lambda}
     \]

  \subsubsection{Cas M/M/S}
    Une généralisation du cas précédent sont les files de type $M/M/S$, où $S$
    dénote le nombre de serveurs. Les lois d'entrée et sortie restent les mêmes.

    Ces files peuvent aussi être représentées avec les chaînes de Markov (voir
    figure~\ref{fig:markov2}).

    \begin{figure}[h]
      \centering
      \makebox[\textwidth]{\begin{tikzpicture}
        [->,shorten >=1pt,auto,node distance=2cm,semithick]
        \tikzstyle{every state}=[fill=white,draw=black,text=black,minimum size=1.1cm]

        \node[state] (A) {0};
        \node[state] (B) [right of=A] {$1$};
        \node[state] (C) [right of=B] {$2$};
        \node[state] (D) [right of=C] {$3$};
        \node[minimum size=1cm] (E) [right of=D] {$\cdots$};
        \node[state] (F) [right of=E] {$S-1$};
        \node[state] (G) [right of=F] {$\phantom{+}S\phantom{+}$};
        \node[state] (H) [right of=G] {$S+1$};
        \node[minimum size=1cm] (I) [right of=H] {$\cdots$};

        \path (A) edge [bend left] node {$\lambda$} (B);
        \path (B) edge [bend left] node {$\mu$} (A);
        \path (B) edge [bend left] node {$\lambda$} (C);
        \path (C) edge [bend left] node {$2\mu$} (B);
        \path (C) edge [bend left] node {$\lambda$} (D);
        \path (D) edge [bend left] node {$3\mu$} (C);
        \path (D) edge [bend left] node {$\lambda$} (E);
        \path (E) edge [bend left] node {$4\mu$} (D);
        \path (E) edge [bend left] node {$\lambda$} (F);
        \path (F) edge [bend left] node {$(S-1)\mu$} (E);
        \path (F) edge [bend left] node {$\lambda$} (G);
        \path (G) edge [bend left] node {$S\mu$} (F);
        \path (G) edge [bend left] node {$\lambda$} (H);
        \path (H) edge [bend left] node {$S\mu$} (G);
        \path (H) edge [bend left] node {$\lambda$} (I);
        \path (I) edge [bend left] node {$S\mu$} (H);
      \end{tikzpicture}}
      \caption{Représentation d'une file M/M/S comme une chaine de Markov
        \cite{procstochs_cc}}
      \label{fig:markov2}
    \end{figure}

    L'étude de ces chaînes est plus compliquée car les états ne sont plus liés
    par la même équation:
      \[
        \left\{\begin{aligned}
          \lambda p_0 & = \phantom{2\times~}\mu p_1 \\
          \lambda p_1 & = 2\times\mu p_2 \\
          & \cdots \\
          \lambda p_{S-2} & = (S-1)\times\mu p_{S-1} \\
          \lambda p_{S-1} & = S\times\mu p_S \\
          \lambda p_S & = S\times\mu p_{S+1} \\
          \lambda p_{S+1} & = S\times\mu p_{S+2} \\
          & \cdots 
        \end{aligned}\right.
      \]

    On peut montrer que le système est en équilibre si et seulement si
    $\rho = \frac \lambda {S\mu} < 1$. Le nombre moyen de clients et temps
    moyen dans le système sont par contre beaucoup moins intuitifs:
    \[
      \begin{aligned}
        N   &= \rho \left(1 + \frac{P_a}{S-\rho}\right) \\
        T_s &= \frac{1}{\mu} \left(1 + \frac{P_a}{S-\rho}\right)
      \end{aligned}
    \]
    où $\displaystyle P_a = P_0 \frac{\rho^S}{(S-1)!(S-\rho)}$ est la
    probabilité d'attendre et $\displaystyle P_0 = \frac{1}{\sum_{k=0}^{S-1}
    \frac{\rho^k}{k!} + \frac {\rho^S}{S!} \frac {1}{1-\rho/S} }$ est la
    probabilité que le système soit vide.

