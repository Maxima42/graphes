\documentclass{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{listings}

\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\newcommand{\brokencell}[2][c]{\begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\lstset{frame=single, breaklines=true,
          breakatwhitespace=true, basicstyle=\scriptsize,
          showstringspaces=false, escapeinside={(*}{*)},
          keywordstyle=\color{deepblue},
          stringstyle=\color{deepred},
          commentstyle=\color{deepgreen},
          literate=
                   {é}{{\'e}}1{É}{{\'E}}1
                   {è}{{\`e}}1{È}{{\`E}}1
                   {ê}{{\^e}}1{Ê}{{\^E}}1
                   {à}{{\`a}}1{À}{{\`A}}1
                   {ù}{{\`u}}1{Ù}{{\`U}}1
                   {û}{{\^u}}1{Û}{{\^U}}1
                   {ô}{{\^o}}1{Ô}{{\^O}}1
                   {ó}{{\'o}}1{Ó}{{\'O}}1
                   {ç}{{\c c}}1{Ç}{{\c C}}1
                   {œ}{{\oe}}1{Œ}{{\OE}}1
        }

\begin{document}
\title{Rapport du projet de théorie des graphes}
\author{Maxence Ahlouche \and Maxime Arthaud \and Korantin Auguste
          \and Martin Carton \and Thomas Forgione \and Thomas Wagner}
\date{7 octobre 2013}
\maketitle
\tableofcontents
\newpage

\section{Présentation de l'équipe}
  Cette équipe a été menée par Korantin Auguste, assisté de son Responsable
  Qualité Martin Carton. Les autres membres de l'équipe sont Thomas Wagner,
  Thomas Forgione, Maxime Arthaud, et Maxence Ahlouche.  Tous les membres de
  l'équipe ont été présents à chacune des séances lors de cette UA.

\section{Modélisation mathématique}
  Nous avons choisi de représenter nos graphes comme une liste de sommets,
  chacun ayant une liste d'arêtes.
  % todo blabla

  Dans la suite nous noterons $n$ le nombre de sommets du graphe.

\section{Graphes eulériens}
  \subsection{Analyse mathématique}
    Un graphe eulérien est un graphe contenant un cycle eulérien, c'est-à-dire
    un chemin parcourant toutes les arêtes du graphe une et une seule fois, en
    revenant au sommet de départ. Pour qu'un graphe soit eulérien, il faut
    évidemment qu'il soit connexe, et il faut également que chacun de ses
    sommets ait un degré pair.

    Un graphe semi-eulérien, quant à lui, contient une chaîne eulérienne:
    celle-ci passe également par toutes les arêtes du graphe une seule et
    unique fois, mais ne retourne pas au point de départ. Un graphe
    semi-eulérien se caractérise également par sa connexité, mais doit avoir
    exactement deux sommets de degré impair. 

  \subsection{Méthode de résolution}
    Afin de trouver une chaîne ou un cycle eulérien dans un graphe, nous avons
    implémenté deux méthodes: une méthode qui teste toutes les possibilités,
    et une autre plus intelligente et moins coûteuse.

    \subsubsection{Matrices latines}
      La première méthode est inspirée des matrices latines: une fois la
      matrice latine du graphe construite, on la multiplie par elle-même $n-1$
      fois afin de connaître tous les chemins de % TODO

  \subsection{Algorithmes}

\section{Graphes hamiltonien}
  \subsection{Analyse mathématique}
    Un graphe (semi-)hamiltonien est un graphe sur lequel on peut
    trouver un cycle(/chemin) passant par tout les sommets une et une seule
    fois.

    Le problème de savoir si un graphe est (semi-)hamiltonien est NP-complet,
    de même que de trouver un cycle ou chemin s'il y en a.

    Il existe cependant des conditions suffisantes pour lesquelles on peut
    affirmer qu'un graphe est hamiltonien ou non.

    Par exemple un graphe complet est forcement hamiltonien (utile dans le cas
    du voyageur de commerce, voir section~\ref{sec:tsp}), il existe aussi des
    conditions sur les degrès des sommets (théorème de Dirac, d'Ore, etc.).

  \subsection{Méthode de résolution}
    Pour tester si un graphe est hamiltonien, nous avons utilisé les théorèmes
    de Dirac et Pósa qui donnent des conditions nécessaires, si ces conditions
    ne sont pas vérifiées, comme il n'y a aucun théorème qui permette
    d'affirmer qu'un graphe n'est pas semi-hamiltonien, on recherche un chemin
    hamiltonien dans ce graphe.

    Pour rechercher un chemin hamiltonien dans un graphe, nous avons écrit un
    algorithme qui recherche parmi tout les chemins possibles. Sa complexité
    dans le pire des cas est donc très mauvaise: $O(n!)$. Comme on peut
    s'arrêter dès qu'on a trouvé un chemin sans devoir tester tout les autres
    chemins possibles, la complexité moyenne sera inférieure.

    Nous avons écrit une version améliorée de cet algorithme qui essaye
    d'éviter les culs de sac.

  \subsection{Algorithmes}

\section{Problème du postier chinois}
  \subsection{Analyse mathématique}
    Le problème du postier chinois consiste à trouver un plus court chemin dans
    un graphe connexe passant au moins une fois par chaque arête, et revenant
    à son point de départ.

    Ce problème peut être réduit à la recherche d'un couplage parfait de coût
    minimum, il peut donc être résolu en temps polynomial dans le cas général.

  \subsection{Méthode de résolution}
    Tout d'abord, si le graphe est Eulérien, il suffit d'appliquer l'algorithme
    d'Euler pour avoir le chemin voulu.

    Sinon, la méthode de résolution consiste à transformer le graphe en graphe
    Eulérien :

    \begin{itemize}
      \item On crée d'abord le graphe partiel contenant uniquement les sommets
        de degré impair
      \item On transforme ensuite ce graphe en clique : pour chaque couple de
        sommets non reliés entre eux, on crée une arête les rejoignant,
        de poids égal au coût le plus faible possible pour rejoindre ces
        sommets dans le graphe inital (ceci se calcul facilement avec
        l'algorithme de Dijkstra)
      \item On cherche le couplage parfait de coût minimum : c'est à dire
        l'ensemble d'arêtes disjointes couvrant tous les sommets du graphe,
        dont la somme des poids doit est le plus faible possible.
        Pour cela, on peut utiliser des algorithmes comme celui d'Edmonds.
        Dans notre implémentation, on a utilisé la bruteforce, par manque
        de temps.
      \item Pour chaque arête de cet ensemble, on double le chemin le plus court
        reliant les nœuds reliés par cette arête dans le graphe initial
      \item On obtient un graphe Eulérien, il suffit d'appliquer l'algorithme
        d'Euler
    \end{itemize}

\section{Problème voyageur de commerce} \label{sec:tsp}
  \subsection{Analyse mathématique}
    On s'intéresse ici à passer par tout les points d'un ensemble une et une
    seule fois en minimisant la distance totale du cycle.

    On peut modéliser ce problème par un graphe complet, dont les arêtes ont un
    coup qui correspond à la distance entre chaque point, on cherche alors le
    cycle hamiltonien de coût minimal. On sait qu'un tel cycle existe car le
    graphe est complet.

    Cependant trouver un tel cycle est un problème NP-difficile, il n'existe
    donc pas d'algorithme efficace pour trouver ce cycle.

  \subsection{Méthode de résolution}
    Bien que la résolution exact de ce problème soit NP-complet, il existe des
    méthodes approchées de résolution.

    Un heuristique simple consiste à partir d'un sommet au hasard du graphe et
    d'aller au sommet le plus proche sur lequel on est pas encore passer (puis
    à retourner au sommet de départ pour boucler le cycle). Cet algorithme est
    en $O(n)$ et donc rapide. Mais il n'offre cependant aucune garantie de
    résultat, il existe même des graphes pour lesquels il donne le pire cycle.

    Il existe aussi des algorithmes non-constructifs comme le 2-opt, qui essaye
    d'améliorer un cycle donné en échangeant des sommets.
    L'application du 2-opt sur les résultats donnés par la méthode du plus proche
    voisin donne des résultats assez intéressants.

    %todo: fourmis ?

  \subsection{Algorithmes}
    \subsubsection{Plus proche voisin}
      \begin{lstlisting}
Entrée : g (Graphe complet)
Sortie : (coût, cycle) où cycle est un cycle hamiltonien construit selon la méthode du plus proche voisin et coût son coût associé sous forme de liste de points
coût = 0
cycle = ["un point de g au hasard"]

tant qu'il reste des points:
    # On ajoute au cycle le point suivant
    plus_proche = "point de g sur lequel on est pas encore passé le plus proche du dernier point du cycle"

    coût += "coût de plus_proche au dernier point du cycle"
    cycle = cycle :: plus_proche

# On ferme le cycle
coût += "coût du dernier au premier point de cycle"
cycle = chemin :: "premier point de chemin"

retourner (coût, cycle)
      \end{lstlisting}

    \subsubsection{$2$-opt}
      \begin{lstlisting}
Entrée : un cycle hamiltonien (liste de sommets) et son coût
Sortie : un cycle hamiltonien et son coût inférieur ou égal au coup d'entrée

pour chaque couple de points (a, b) dans le cycle:
    nouveau_coût = coût
                     - "coût de a à son successeur dans le cycle"
                     - "coût de b à son successeur dans le cycle"
                     + "coût de a à b"
                     + "coût du successeur de a et au successeur de b dans le cycle"

    si nouveau_coût < coût:
        coût = nouveau_coût
        cycle = cycle crée en échangeant a et b dans cycle

retourner (coût, cycle)
      \end{lstlisting}

  \subsection{Tests}
    Nous avons lancé cet algorithme sur plusieurs ``grands''
    graphes\footnote{Trouvés sur
      \url{http://www.iwr.uni-heidelberg.de/groups/comopt/software/TSPLIB95/}.
    }, les résultats sont présentés dans la table~\ref{table:tsp}\footnote{N/A
    indique que l'algorithme est trop long ou cause une erreur à cause de la
    taille du graphe, pour chaque méthode de résolution sont données les
    longueurs des chemins trouvés et l'erreur relative avec le résultat
    optimum.}.

    \begin{table}[h]
      \makebox[\textwidth]{%
      \centering
      \begin{tabular}{| c | c | c | c | c | c |}
      \hline
        \brokencell{Fichier de\\test}
      & \brokencell{Résultat\\optimum}
      & \brokencell{Plus proche\\voisin}
      & \brokencell{Plus proche\\voisin + 2-opt}
      & \brokencell{Plus proche\\voisin amélioré}
      & \brokencell{Plus proche\\voisin amélioré\\+ 2-opt}\\
      \hline
      berlin52.tsp & $7542$  & $8981/19.1\%$ & $8060/6.7\%$ & $7972/5.7\%$ & $7810/3.6\%$ \\
      bier127.tsp & $118282$  & $137297/16.7\%$ & $125669/6.2\%$ & $127857/8.1\%$ & $122072/3.2\%$ \\
      d657.tsp & $48912$  & $62176/27.1\%$ & N/A & N/A & N/A \\
      u724.tsp     & $41910$ & $55344,32.1\%$ & N/A & N/A & N/A \\
      fl1577.tsp & $22249$  & N/A & N/A & N/A & N/A \\
      \hline  
      \end{tabular}
      }
      \caption{Résultats pour TSP}
      \label{table:tsp}
    \end{table}

    On remarque que bien qu'il ne fournisse aucune garantie, l'algorithme du
    plus proche voisin donne des résultats plutôt bons. % todo: mal dit

\section{Conclusion}

\section{Annexe}
  \lstlistoflistings
  %todo: listings de tout les codes
  \lstinputlisting[language=python, caption=Classe pour représenter un graphe]{graphs.py}
  \lstinputlisting[language=python, caption=Codes à la connexité]{connected.py}
  \lstinputlisting[language=python, caption=Codes relatifs au graphes eulériens]{eulerian.py}
  \lstinputlisting[language=python, caption=Codes relatifs au graphes hamiltonien]{hamiltonian.py}
  \lstinputlisting[language=python, caption=Codes relatifs postier chinois]{postier_chinois.py}
  \lstinputlisting[language=python, caption=Codes relatifs au TSP]{tsp.py}
  \lstinputlisting[language=python, caption=Tests]{tests.py}
\end{document}

