\documentclass{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{verbatim}
\usepackage{listings}

\newcommand{\brokencell}[2][c]{\begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}

\lstset{language=python, frame=single, breaklines=true,
          breakatwhitespace=true, basicstyle=\ttfamily\scriptsize,
          showstringspaces=false,
          literate=
                   {é}{{\'e}}1{É}{{\'E}}1
                   {è}{{\`e}}1{È}{{\`E}}1
                   {ê}{{\^e}}1{Ê}{{\^E}}1
                   {à}{{\`a}}1{À}{{\`A}}1
                   {ù}{{\`u}}1{Ù}{{\`U}}1
                   {ô}{{\^o}}1{Ô}{{\^O}}1
                   {ç}{{\c c}}1{Ç}{{\c C}}1
                   {œ}{{\oe}}1{Œ}{{\OE}}1
        }

\begin{document}
\title{Rapport du projet de théorie des graphes}
\author{Maxence Ahlouche \and Maxime Arthaud \and Korantin Auguste
          \and Martin Carton \and Thomas Forgione \and Thomas Wagner}
\date{7 octobre 2013}
\maketitle
\tableofcontents
\lstlistoflistings
\newpage

\section{Présentation de l'équipe}
  Cette équipe a été menée par Korantin Auguste, assisté de son Responsable
  Qualité Martin Carton. Les autres membres de l'équipe sont Thomas Wagner,
  Thomas Forgione, Maxime Arthaud, et Maxence Ahlouche.  Tous les membres de
  l'équipe ont été présents à chacune des séances lors de cette UA.

\section{Modélisation mathématique}
  Nous avons choisi de représenter nos graphes comme une liste de sommets,
  chacun ayant une liste d'arêtes.
  % todo blabla

\section{Analyse mathématique}
  \subsection{Graphes eulériens}
  \subsection{Graphes hamiltonien}
    Un graphe hamiltonien est un graphe est un graphe sur lequel on peut
    trouver un cycle passant par tout les sommets une et une seule fois.

    Le problème de savoir si un graphe admet un cycle, ou même un chemin
    hamiltonien est NP-complet, de même que de trouver un tel cycle ou chemin
    s'il y en a.

    Il existe cependant des conditions suffisantes pour lesquelles on peut
    affirmer qu'un graphe est hamiltonien ou non.
    % todo: graphe complet, théorème de Dirac/Ore, etc

  \subsection{Problème du postier chinois}
  \subsection{Problème voyageur de commerce}
    On s'intéresse ici à passer par tout les points d'un ensemble une et une
    seule fois en minimisant la distance totale du cycle.

    On peut modéliser ce problème par un graphe complet, dont les arêtes ont un
    coup qui correspond à la distance entre chaque point, on cherche alors le
    cycle hamiltonien de coût minimal. On sait qu'un tel cycle existe car le
    graphe est complet.

    Cependant trouver un tel graphe est un problème NP-difficile, il n'existe
    donc pas d'algorithme efficaces pour trouver ce cycle.

    Il existe cependant plusieurs heuristique pour trouver un cycle dans ce
    graphe.

    Un heuristique simple consiste à partir d'un sommet au hasard du graphe et
    d'aller au sommet le plus proche sur lequel on est pas encore passer (puis
    à retourner au sommet de départ pour boucler le cycle). Cet algorithme
    n'offre cependant aucune garantie de résultat, il existe même des graphes
    pour lesquels il donne le pire cycle.

    Il existe aussi des algorithmes non-constructifs comme le 2-opt, qui essaye
    d'améliorer un cycle donné en échangeant des sommets.

\section{Méthode de résolution}
  \subsection{Graphes eulériens}
  \subsection{Graphes hamiltonien}
  \subsection{Problème du postier chinois}
  \subsection{Problème voyageur de commerce}

\section{Algorithmes}
  \subsection{Graphes eulériens}
  \subsection{Graphes hamiltonien}
  \subsection{Problème du postier chinois}
  \subsection{Problème voyageur de commerce}
  
\section{Conclusion}

\section{Tests}
\subsection{Problème voyageur de commerce}
    Nous avons lancé cet algorithme sur plusieurs ``grands''
    graphes\footnote{Trouvés sur
      \url{http://www.iwr.uni-heidelberg.de/groups/comopt/software/TSPLIB95/}.
    }, les résultats sont présentés dans la table \ref{table:tsp}\footnote{N/A
    indique que l'algorithme est trop long ou cause une erreur à cause de la
    taille du graphe, pour chaque méthode de résolution sont données les
    longueurs des chemins trouvés et l'erreur relative avec le résultat
    optimum.}.

    \begin{center}\begin{table}[h]
      \centering
      \begin{tabular}{| c | c | c | c | c |}
      \hline
        Fichier de test
      & \brokencell{Résultat\\optimum}
      & \brokencell{Plus proche\\voisin}
      & \brokencell{Plus proche\\voisin + 2-opt}
      & \brokencell{Plus proche\\voisin amélioré\\+ 2-opt}\\
      \hline
      berlin52.tsp & $7542$  & $8981/19.1\%$ & $8060/6.7\%$ & $7810/3.6\%$ \\
      bier127.tsp & $118282$  & $137297/16.7\%$ & $125669/6.2\%$ & N/A \\
      d657.tsp & $48912$  & $62176/27.1\%$ & N/A & N/A \\
      fl1577.tsp & $22249$  & N/A & N/A & N/A\\
      u724.tsp     & $41910$ & $55344,32.1\%$ & N/A & N/A \\
      \hline  
      \end{tabular}
      \caption{Résultats pour TSP}
      \label{table:tsp}
    \end{table}\end{center}

    On remarque que bien qu'il ne fournisse aucune garantie, l'algorithme du
    plus proche voisin donne des résultats plutôt bons. % todo: mal dit


\section{Annexe}
  %todo: listings de tout les codes
  \lstinputlisting[caption=Classe pour représenter un graphe]{graphs.py}
  \lstinputlisting[caption=Algorithmes relatifs au graphes eulériens]{eulerian.py}
  \lstinputlisting[caption=Algorithmes relatifs au graphes hamiltonien]{hamiltonian.py}
  \lstinputlisting[caption=Algorithmes relatifs au TSP]{tsp.py}
  \lstinputlisting[caption=Tests]{tests.py}

\begin{comment} % todo: à merger ci-dessus
\section{TPs}
    Nous avons commencé les TPs par le choix du langage utilisé pour
    implémenter nos algorithmes: le python, (pour la simplicité qu'il offre pour
    représenter les graphes et la lecture/le parsage d'un fichier représentant
    un graphe), puis l'écriture des classes permettant de représenter un
    graphe.

    Puis nous nous sommes séparés en trois binômes ayant travaillé sur:
    \begin{itemize}
      \item un algorithme permettant de savoir si un graphe est connexe ou non
        (dans le cas non orienté);
      \item  la création d'un algorithme (brute force) qui trouve un chemin
        hamiltonien dans un graphe;
      \item  la création de quelques fonctions qui génèrent des graphes simples
        de tests.
    \end{itemize}
    
\section{Problème 1}
  \subsection{Exercice 1}
    Pour représenter ce problème par un graphe, on représente les carrefours
    par les nœuds du graphe et les routes par des arêtes. Goudronner toutes les
    routes revient alors à parcourir toutes les arêtes une et une seule fois
    dans le graphe.

    Afin que le problème soit soluble, il faut que le graphe soit eulérien,
    c'est à dire connexe et que chaque nœud ait un nombre pair d'arêtes. Cette
    condition n'est pas nécessaire, car il peut toutefois aussi contenir
    exactement deux nœuds ayant un nombre impair d'arêtes, si on part d'un de
    ces deux nœuds (et on arrivera à l'autre).

    On peut utiliser l'algorithme d'Euler, qui consiste à trouver un cycle dans
    le graphe (en le parcourant «~au hasard~»), puis à s'appeler récursivement
    sur le sous-graphe construit en retirant les arêtes du cycle trouvé, en
    partant d'un nœud du cycle qui n'a pas d'arêtes qui n'appartiennent pas à
    ce cycle.

  \subsection{Exercice 2}
    On commence par construire le graphe représentant le musée où les arêtes
    représentent les portes et les sommets des salles du musée. Par définition,
    l'objectif de cet enfant est réalisable si ce graphe est hamiltonien ou
    semi-hamiltonien.

    Un graphe hamiltonien est un graphe qui contient au moins un cycle
    hamiltonien, c'est à dire un cycle passant une et une seule fois par chaque
    sommet en revenant au sommet de départ. S'il est uniquement
    semi-hamiltonien, il n'a qu'une chaîne hamiltonienne: l'enfant ne se
    retrouvera pas dans la salle de départ.

    Un moyen simple de résoudre ce problème est de tester toutes les
    possibilités de chaînes, jusqu'à en trouver une qui soit hamiltonienne.
    Toutefois, cette solution a une complexité en $O(n!)$ (avec $n$ le nombre
    d'arêtes), et par conséquent est peu envisageable pour des graphes de
    grande taille.

    Nous avons implémenté cet algorithme dans la fonction
    \verb+hamiltonian_path+.
    
    Pour améliorer cet algorithme, on peut arrêter de chercher
    quand le graphe restant à parcourir n'est pas connexe.

    Un autre moyen serait de calculer les puissances successives de la matrice
    latine représentant le graphe. Il suffirait alors d'éliminer tous les
    chemins ne contenant pas une et une seule fois tous les sommets du graphe.
    Lors du calcul des puissances successives, on peut remplacer par des 0 tous
    les chemins contenant deux fois le même sommet. Toutefois, cet algorithme
    est également très complexe.

    Ce problème étant NP-complet, il n'existe pas de moyen simple de déterminer
    le chemin, ni même si un tel chemin existe pour un graphe donné quelconque.

  \subsection{Exercice 3}
    Il est possible de résoudre le premier problème en transformant le graphe:
    il suffit de créer le graphe dont les sommets sont les arêtes du premier
    graphe, et les arêtes sont les sommets de ce premier graphe. Ce nouveau
    graphe est appelé «~line graph~». En trouvant une chaîne hamiltonienne
    dans ce graphe, on obtient une chaîne eulérienne.

    Par contre, il est impossible de transformer le problème 2 en problème 1.
    Le problème 2 est NP-complet, alors que le premier est soluble en $O(n)$ (à
    l'aide par exemple de l'algorithme de Hierholzer). Les 2 problèmes ne sont
    donc pas équivalents.

    %todo: parler des graphes orientés

\section{Problème 2}
  \subsection{Exercice 1}
    Si le graphe est eulérien, ou semi-eulérien, l'algorithme d'Euler résout le
    problème, en trouvant un cycle qui passe par toutes les routes, une et une
    seule fois: c'est donc forcément la solution la plus efficace.

    Sinon, il suffit de transformer le graphe en un graphe eulérien en créant
    des arêtes: on prend le graphe partiel contenant uniquement les sommets de
    degré impair, qu'on transforme en clique. Pour cela, pour chaque couple de
    sommets non reliés entre eux, on crée une arête les rejoignant, de poids
    égal au coût le plus faible possible pour rejoindre ces sommets sur le
    graphe total.

    Puis on cherche le couplage parfait de coût minimum: c'est à dire
    l'ensemble des arêtes disjointes couvrant tous les sommets du graphe (il
    existe car on aura forcément un nombre de sommets pair dans le graphe
    partiel).

    Il suffit de doubler le nombre des arêtes de cet ensemble, on obtient ainsi
    un graphe eulérien, et avec l'algorithme d'Euler, on a un parcours passant
    par toutes les arêtes, qui est donc optimal (cf.\ le cas du graphe eulérien
    ci-dessus).

  \subsection{Exercice 2}
    % déjà mergé

  \subsection{Exercice 3}
    Ce problème ressemble au problème précédent sans la contrainte de ne passer
    qu'une seule fois par ville/point à percer. On pourrait donc utiliser les
    mêmes algorithmes, mais il pourrait y avoir des solutions plus efficaces en
    repassant par une ville déjà visitée.

%\section{Problème 3}
%  On en parle un peu juste pour faire bien ?
 
\end{comment}
\end{document}

